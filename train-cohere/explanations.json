{
  "longest-substring-without-repeating-characters0": "The algorithm uses a sliding window with two pointers, left and right, to iterate through the string. It also uses a set to store the unique characters in the current window.1. Initialize left and right pointers to the start of the string, and maxLength to 0.2. Check if the character at the right index is in the set.   - If it's not in the set, add the character to the set, update maxLength, and move the right pointer forward.   - If it's in the set, remove the character at the left index from the set, and move the left pointer forward.3. Repeat step 2 until the right pointer reaches the end of the string.4. Return maxLength. The algorithm runs in O(n) time, where n is the length of the input string.",
  "longest-substring-without-repeating-characters1": "The algorithm employs a sliding window approach with two pointers, left and right, to traverse the string. It uses a set to store unique characters in the current window and initializes the left and right pointers to the start of the string. By checking if the character at the right index is in the set, it adds or removes characters accordingly and updates the maxLength. The process continues until the right pointer reaches the end of the string, and the maxLength is returned. The algorithm's time complexity is O(n).",
  "longest-substring-without-repeating-characters2": "Using a sliding window technique, the algorithm iterates through the string with two pointers, left and right. It maintains a set to keep track of unique characters in the current window. The algorithm starts with initializing the left and right pointers to the beginning of the string and sets maxLength to 0. It checks if the character at the right index is in the set. If not, it adds the character to the set, updates maxLength if necessary, and moves the right pointer forward. If the character is in the set, it removes the character at the left index from the set and moves the left pointer forward. This process continues until the right pointer reaches the end of the string, and maxLength is returned. The algorithm's time complexity is O(n).",
  "longest-substring-without-repeating-characters3": "The algorithm solves the problem of finding the longest substring without repeating characters using a sliding window strategy. It maintains two pointers, left and right, and a set to keep track of unique characters in the current window. The algorithm initializes the left and right pointers to the start of the string and sets maxLength to 0. It iterates through the string by moving the right pointer forward. If the character at the right index is not in the set, it adds the character to the set, updates maxLength if necessary, and moves the right pointer forward. If the character is in the set, it removes the character at the left index from the set and moves the left pointer forward. This process continues until the right pointer reaches the end of the string, and maxLength is returned. The time complexity of the algorithm is O(n), where n is the length of the input string.",
  "longest-substring-without-repeating-characters4": "The algorithm utilizes a sliding window technique to find the longest substring without repeating characters. It maintains two pointers, left and right, to represent the start and end of the window. Additionally, it uses a set to store unique characters within the current window. The algorithm begins by initializing the left and right pointers to the start of the string and sets maxLength to 0. It iterates through the string, moving the right pointer forward. If the character at the right index is not in the set, it adds the character to the set, updates maxLength if necessary, and moves the right pointer forward. If the character is already in the set, it removes the character at the left index from the set and moves the left pointer forward. This process continues until the right pointer reaches the end of the string, and maxLength is returned. The time complexity of the algorithm is O(n), where n is the length of the input string.",
  "longest-substring-without-repeating-characters5": "The algorithm solves the problem of finding the longest substring without repeating characters by utilizing a sliding window approach. It maintains two pointers, left and right, and a set to store the unique characters within the current window. Initially, the left and right pointers are set to the start of the string, and maxLength is initialized to 0. The algorithm iterates through the string, moving the right pointer forward. If the character at the right index is not present in the set, it adds the character to the set, updates maxLength if necessary, and moves the right pointer forward. If the character is already in the set, it removes the character at the left index from the set and moves the left pointer forward. This process continues until the right pointer reaches the end of the string, and the algorithm returns the maxLength, representing the length of the longest substring without repeating characters. The time complexity is O(n), where n is the length of the input string.",
  "longest-substring-without-repeating-characters6": "To find the longest substring without repeating characters, the algorithm utilizes a sliding window technique with two pointers, left and right. It maintains a set to store the unique characters within the current window. The algorithm initializes the left and right pointers to the start of the string and sets maxLength to 0. It iterates through the string, moving the right pointer forward. If the character at the right index is not in the set, it adds the character to the set, updates maxLength if necessary, and moves the right pointer forward. If the character is already in the set, it removes the character at the left index from the set and moves the left pointer forward. This process continues until the right pointer reaches the end of the string, and the algorithm returns the maxLength as the length of the longest substring without repeating characters. The time complexity is O(n), where n is the length of the input string.",
  "longest-substring-without-repeating-characters7": "The longest substring without repeating characters is found using a sliding window approach with two pointers, left and right. A set is maintained to store the unique characters within the current window. Initially, the left and right pointers are set to the start of the string, and maxLength is set to 0. The algorithm iterates through the string, moving the right pointer forward. If the character at the right index is not present in the set, it adds the character to the set, updates maxLength if necessary, and moves the right pointer forward. If the character is already in the set, it removes the character at the left index from the set and moves the left pointer forward. This process continues until the right pointer reaches the end of the string, and the algorithm returns the maxLength, representing the length of the longest substring without repeating characters. The time complexity is O(n), where n is the length of the input string.",
  "longest-substring-without-repeating-characters8": "Using a sliding window technique, the algorithm aims to find the longest substring without repeating characters. It maintains two pointers, left and right, and a set to store the unique characters in the current window. Initially, the left and right pointers are set to the start of the string, and maxLength is set to 0. The algorithm iterates through the string, moving the right pointer forward. If the character at the right index is not found in the set, it adds the character to the set, updates maxLength if necessary, and moves the right pointer forward. If the character is already in the set, it removes the character at the left index from the set and moves the left pointer forward. This process continues until the right pointer reaches the end of the string, and the algorithm returns the maxLength as the length of the longest substring without repeating characters. The time complexity of the algorithm is O(n), where n is the length of the input string.",
  "longest-substring-without-repeating-characters9": "The algorithm employs a sliding window approach with two pointers, left and right, to find the longest substring without repeating characters. It uses a set to keep track of unique characters within the current window. Initially, the left and right pointers are set to the start of the string, and maxLength is initialized to 0. The algorithm iterates through the string, moving the right pointer forward. If the character at the right index is not present in the set, it adds the character to the set, updates maxLength if necessary, and moves the right pointer forward. If the character is already in the set, it removes the character at the left index from the set and moves the left pointer forward. This process continues until the right pointer reaches the end of the string, and the algorithm returns the maxLength as the length of the longest substring without repeating characters. The time complexity is O(n), where n is the length of the input string.",
  "longest-substring-without-repeating-characters10": "Using a sliding window technique, the algorithm finds the longest substring without repeating characters. It maintains two pointers, left and right, to represent the start and end of the window. A set is utilized to store the unique characters within the current window. Initially, the left and right pointers are set to the start of the string, and maxLength is set to 0. The algorithm iterates through the string, moving the right pointer forward. If the character at the right index is not in the set, it adds the character to the set, updates maxLength if necessary, and moves the right pointer forward. If the character is already in the set, it removes the character at the left index from the set and moves the left pointer forward. This process continues until the right pointer reaches the end of the string, and the algorithm returns the maxLength as the length of the longest substring without repeating characters. The time complexity is O(n), where n is the length of the input string.",
  "longest-substring-without-repeating-characters11": "The algorithm solves the problem of finding the longest substring without repeating characters using a sliding window strategy. It maintains two pointers, left and right, and a set to store the unique characters within the current window. Initially, the left and right pointers are set to the start of the string, and maxLength is initialized to 0. The algorithm iterates through the string, moving the right pointer forward. If the character at the right index is not in the set, it adds the character to the set, updates maxLength if necessary, and moves the right pointer forward. If the character is already in the set, it removes the character at the left index from the set and moves the left pointer forward. This process continues until the right pointer reaches the end of the string, and the algorithm returns the maxLength as the length of the longest substring without repeating characters. The time complexity is O(n), where n is the length of the input string.",
  "longest-substring-without-repeating-characters12": "The algorithm utilizes a sliding window technique with two pointers, left and right, to find the longest substring without repeating characters. It maintains a set to store the unique characters within the current window. The algorithm starts by initializing the left and right pointers to the start of the string and sets maxLength to 0. It iterates through the string, moving the right pointer forward. If the character at the right index is not present in the set, it adds the character to the set, updates maxLength if necessary, and moves the right pointer forward. If the character is already in the set, it removes the character at the left index from the set and moves the left pointer forward. This sliding window process continues until the right pointer reaches the end of the string. Finally, the algorithm returns the maxLength, which represents the length of the longest substring without repeating characters. The time complexity of the algorithm is O(n), where n is the length of the input string.", 
  "longest-substring-without-repeating-characters13": "The algorithm finds the longest substring without repeating characters using a sliding window approach. It maintains two pointers, left and right, to represent the start and end of the window. A set is used to store the unique characters within the current window. Initially, the left and right pointers are set to the start of the string, and maxLength is set to 0. The algorithm iterates through the string, moving the right pointer forward. If the character at the right index is not present in the set, it adds the character to the set, updates maxLength if necessary, and moves the right pointer forward. If the character is already in the set, it removes the character at the left index from the set and moves the left pointer forward. This process continues until the right pointer reaches the end of the string, and the algorithm returns the maxLength as the length of the longest substring without repeating characters. The time complexity is O(n), where n is the length of the input string.",
  "longest-substring-without-repeating-characters14": "Using a sliding window technique, the algorithm determines the longest substring without repeating characters. It utilizes two pointers, left and right, to define the window boundaries. A set is employed to track the unique characters within the window. The algorithm initializes the left and right pointers to the start of the string and sets maxLength to 0. It iterates through the string, moving the right pointer forward. If the character at the right index is not in the set, it adds the character to the set, updates maxLength if necessary, and moves the right pointer forward. If the character is already in the set, it removes the character at the left index from the set and moves the left pointer forward. This process continues until the right pointer reaches the end of the string, and the algorithm returns the maxLength, representing the length of the longest substring without repeating characters. The time complexity is O(n), where n is the length of the input string.",
  "median-of-two-sorted-arrays0": "1. Choose the smaller array as nums1 so that the problem is simpler with less log(n) complexity.2. Use Binary Search (BS) to partition the smallest array.3. Now we calculate the position of partition in the larger array (nums2) having fetched the smaller one.4. Find the four important numbers - maxSize - left and right of partition in the two arrays.5. If maxSizeLeft <= minSizeRight and maxSizeLeft2 <= minSizeRight2, then the partition of both arrays is correct, if not, adjust the partition of nums1. If maxLeftX > minRightY, move the BS partition to the left; if maxLeftY > minRightX, move the BS partition to the right.6. When the correct partition is found, calculate the median based on the length of the merged array, even or odd.",
  "median-of-two-sorted-arrays1": "The 'Median of Two Sorted Arrays' problem can be solved by choosing the smaller array, nums1, and applying Binary Search (BS) with array partitioning. Find the partition's position in nums2 and important numbers. Adjust the partition if necessary and calculate the median based on the merged array's length.",
  "median-of-two-sorted-arrays2": "To solve the 'Median of Two Sorted Arrays' problem, select the smaller array, nums1, and use Binary Search (BS) with array partitioning. Determine the partition's position in nums2 and find key numbers. Adjust the partition if needed and calculate the median based on the merged array's length.",
  "median-of-two-sorted-arrays3": "The 'Median of Two Sorted Arrays' problem can be solved using Binary Search (BS) and array partitioning. Choose the smaller array, nums1, and find the partition's position in nums2. Adjust the partition if necessary and calculate the median based on the merged array's length.",
  "median-of-two-sorted-arrays4": "Solving the 'Median of Two Sorted Arrays' problem involves choosing the smaller array, nums1, and applying Binary Search (BS) with array partitioning. Determine the partition's position in nums2 and find key numbers. Adjust the partition as needed and calculate the median based on the merged array's length.",
  "median-of-two-sorted-arrays5": "To solve the 'Median of Two Sorted Arrays' problem, select the smaller array, nums1, and use Binary Search (BS) with array partitioning. Determine the partition's position in nums2 and find important numbers. Adjust the partition if necessary and calculate the median based on the merged array's length.",
  "median-of-two-sorted-arrays6": "The 'Median of Two Sorted Arrays' problem can be solved by choosing the smaller array, nums1, and applying Binary Search (BS) with array partitioning. Find the partition's position in nums2 and adjust it if needed. Calculate the median based on the merged array's length.",
  "median-of-two-sorted-arrays7": "Solving the 'Median of Two Sorted Arrays' problem involves selecting the smaller array, nums1, and using Binary Search (BS) with array partitioning. Determine the partition's position in nums2 and adjust if necessary. Calculate the median based on the merged array's length.",
  "median-of-two-sorted-arrays8": "To solve the 'Median of Two Sorted Arrays' problem, choose the smaller array, nums1, and apply Binary Search (BS) with array partitioning. Determine the partition's position in nums2 and adjust it if required. Calculate the median based on the merged array's length.",
  "median-of-two-sorted-arrays9": "The 'Median of Two Sorted Arrays' problem can be solved by choosing the smaller array, nums1, and applying Binary Search (BS) with array partitioning. Determine the partition's position in nums2 and find key numbers. Adjust the partition as necessary and calculate the median based on the merged array's length.",
  "median-of-two-sorted-arrays10": "Solving the 'Median of Two Sorted Arrays' problem involves choosing the smaller array, nums1, and utilizing Binary Search (BS) with array partitioning. Determine the partition's position in nums2 and find important numbers. Adjust the partition if needed and calculate the median based on the merged array's length.",
  "median-of-two-sorted-arrays11": "To solve the 'Median of Two Sorted Arrays' problem, select the smaller array, nums1, and use Binary Search (BS) with array partitioning. Find the partition's position in nums2 and adjust it accordingly. Calculate the median based on the merged array's length, considering both even and odd cases.",
  "median-of-two-sorted-arrays12": "The 'Median of Two Sorted Arrays' problem can be solved by choosing the smaller array, nums1, and applying Binary Search (BS) with array partitioning. Determine the partition's position in nums2 and find key numbers. Adjust the partition as necessary and calculate the median, considering both even and odd cases.",
  "median-of-two-sorted-arrays13": "Solving the 'Median of Two Sorted Arrays' problem involves selecting the smaller array, nums1, and using Binary Search (BS) with array partitioning. Determine the partition's position in nums2 and find important numbers. Adjust the partition if required and calculate the median, considering both even and odd cases.",
  "median-of-two-sorted-arrays14": "To solve the 'Median of Two Sorted Arrays' problem, choose the smaller array, nums1, and apply Binary Search (BS) with array partitioning. Determine the partition's position in nums2 and adjust it as needed. Calculate the median, considering both even and odd cases.",
  "longest-palindromic-substring0": "1. Initialize `start` and `maxLength` for result substring.2. Iterate through the given string `s` using the index `i`.3. For each index `i`, create two pointers `l` and `r` starting at `i`.4. Check if there's a consecutive sequence of identical characters, increment the right pointer `r` until the end of the sequence is reached.5. Update the index `i` to the current value of `r`.6. Expand the pointers `l` and `r` outwards to find the longest palindromic substring, checking that characters on both sides are equal.7. If the current length of the substring is greater than `maxLength`, update `start` and `maxLength`.8. Return the longest palindromic substring using the `start` and `maxLength`.",
  "longest-palindromic-substring1": "Initialize `start` and `maxLength` for the result substring. Iterate through the given string `s` and create pointers `l` and `r` for each index. Expand the pointers to find the longest palindromic substring, updating `start` and `maxLength` as needed.",
  "longest-palindromic-substring2": "To find the longest palindromic substring, initialize `start` and `maxLength`. Iterate through `s` using index `i` and create pointers `l` and `r`. Expand the pointers to check for palindromes and update `start` and `maxLength` accordingly.",
  "longest-palindromic-substring3": "The 'Longest Palindromic Substring' problem can be solved by initializing `start` and `maxLength`. Iterate through `s` using index `i` and create pointers `l` and `r`. Expand the pointers to find the longest palindromic substring, updating `start` and `maxLength` as necessary.",
  "longest-palindromic-substring4": "Solving the 'Longest Palindromic Substring' problem involves initializing `start` and `maxLength`. Iterate through `s` using index `i` and create pointers `l` and `r`. Expand the pointers to find the longest palindromic substring, updating `start` and `maxLength` when necessary.",
  "longest-palindromic-substring5": "The 'Longest Palindromic Substring' problem can be solved by initializing `start` and `maxLength`. Iterate through the given string `s` and create pointers `l` and `r` for each index. Expand the pointers to find the longest palindromic substring, updating `start` and `maxLength` as needed.",
  "longest-palindromic-substring6": "To find the longest palindromic substring, initialize `start` and `maxLength`. Iterate through `s` using index `i` and create pointers `l` and `r`. Expand the pointers to check for palindromes and update `start` and `maxLength` accordingly.",
  "longest-palindromic-substring7": "The 'Longest Palindromic Substring' problem can be solved by initializing `start` and `maxLength`. Iterate through `s` using index `i` and create pointers `l` and `r`. Expand the pointers to find the longest palindromic substring, updating `start` and `maxLength` as necessary.",
  "longest-palindromic-substring8": "Solving the 'Longest Palindromic Substring' problem involves initializing `start` and `maxLength`. Iterate through `s` using index `i` and create pointers `l` and `r`. Expand the pointers to find the longest palindromic substring, updating `start` and `maxLength` when necessary.",
  "longest-palindromic-substring9": "Initialize `start` and `maxLength` for the result substring. Iterate through the given string `s` and create pointers `l` and `r` for each index. Expand the pointers to find the longest palindromic substring, updating `start` and `maxLength` as needed.",
  "longest-palindromic-substring10": "To find the longest palindromic substring, initialize `start` and `maxLength`. Iterate through `s` using index `i` and create pointers `l` and `r`. Expand the pointers to check for palindromes and update `start` and `maxLength` accordingly.",
  "longest-palindromic-substring11": "The 'Longest Palindromic Substring' problem can be solved by initializing `start` and `maxLength`. Iterate through the given string `s` and create pointers `l` and `r` for each index. Expand the pointers to find the longest palindromic substring, updating `start` and `maxLength` as needed.",
  "longest-palindromic-substring12": "To solve the 'Longest Palindromic Substring' problem, start by initializing `start` and `maxLength`. Iterate through the string `s` using index `i` and create pointers `l` and `r`. Expand the pointers to find the longest palindromic substring, updating `start` and `maxLength` when necessary.",
  "longest-palindromic-substring13": "The 'Longest Palindromic Substring' problem can be solved by initializing `start` and `maxLength`. Iterate through `s` using index `i` and create pointers `l` and `r`. Expand the pointers to find the longest palindromic substring, updating `start` and `maxLength` as necessary.",
  "longest-palindromic-substring14": "Solving the 'Longest Palindromic Substring' problem involves initializing `start` and `maxLength`. Iterate through `s` using index `i` and create pointers `l` and `r`. Expand the pointers to find the longest palindromic substring, updating `start` and `maxLength` when necessary.",
  "reverse-integer0": "The algorithm initializes `res` as 0. Then, we determine the sign of the input integer and take its absolute value. We use a while loop to iterate through each digit of `x` from right to left. In each iteration, we multiply the current `res` by 10 and add the last digit of `x` to it. The last digit of `x` is obtained by `x % 10`. After adding the last digit, we remove it from `x` by doing either `x /= 10` or `x //= 10`.After processing all the digits, we adjust `res` with the sign we computed earlier. Finally, we check if the reversed integer is within the 32-bit integer range. If it is, we return the result; otherwise, we return 0.",
  "reverse-integer1": "To reverse an integer, initialize `res` as 0. Determine the sign of the input integer and take its absolute value. Iterate through each digit of `x` from right to left, multiplying `res` by 10 and adding the last digit of `x` to it.",
  "reverse-integer2": "The algorithm for reversing an integer starts by initializing `res` as 0. Determine the sign of the input integer and take its absolute value. Iterate through each digit of `x` from right to left, updating `res` by multiplying it by 10 and adding the last digit of `x`.",
  "reverse-integer3": "To reverse an integer, start by initializing `res` as 0. Determine the sign of the input integer and take its absolute value. Iterate through each digit of `x` from right to left, updating `res` by multiplying it by 10 and adding the last digit of `x`.",
  "reverse-integer4": "The algorithm to reverse an integer begins with initializing `res` as 0. Determine the sign of the input integer and take its absolute value. Iterate through each digit of `x` from right to left, updating `res` by multiplying it by 10 and adding the last digit of `x`.",
  "reverse-integer5": "To reverse an integer, set `res` to 0. Determine the sign of the input integer and take its absolute value. Iterate through each digit of `x` from right to left, multiplying `res` by 10 and adding the last digit of `x` to it.",
  "reverse-integer6": "The algorithm for reversing an integer involves initializing `res` as 0. Determine the sign of the input integer and take its absolute value. Iterate through each digit of `x` from right to left, updating `res` by multiplying it by 10 and adding the last digit of `x`.",
  "reverse-integer7": "To reverse an integer, start by setting `res` to 0. Determine the sign of the input integer and take its absolute value. Iterate through each digit of `x` from right to left, updating `res` by multiplying it by 10 and adding the last digit of `x`.",
  "reverse-integer8": "The algorithm to reverse an integer begins with initializing `res` as 0. Determine the sign of the input integer and take its absolute value. Iterate through each digit of `x` from right to left, updating `res` by multiplying it by 10 and adding the last digit of `x`.",
  "reverse-integer9": "To reverse an integer, set `res` to 0. Determine the sign of the input integer and take its absolute value. Iterate through each digit of `x` from right to left, multiplying `res` by 10 and adding the last digit of `x` to it.",
  "reverse-integer10": "The algorithm for reversing an integer involves initializing `res` as 0. Determine the sign of the input integer and take its absolute value. Iterate through each digit of `x` from right to left, updating `res` by multiplying it by 10 and adding the last digit of `x`.",
  "reverse-integer11": "To reverse an integer, start by setting `res` to 0. Determine the sign of the input integer and take its absolute value. Iterate through each digit of `x` from right to left, updating `res` by multiplying it by 10 and adding the last digit of `x`.",
  "reverse-integer12": "The algorithm to reverse an integer begins with initializing res as 0. Determine the sign of the input integer and take its absolute value. Iterate through each digit of x from right to left, updating res by multiplying it by 10 and adding the last digit of x. After processing all the digits, adjust res with the sign computed earlier. Finally, check if the reversed integer is within the 32-bit range and return the result or 0 accordingly.",
  "reverse-integer13": "To reverse an integer, start by initializing res as 0. Determine the sign of the input integer and take its absolute value. Iterate through each digit of x from right to left, updating res by multiplying it by 10 and adding the last digit of x. Adjust res based on the computed sign and return the result within the 32-bit range.",
  "reverse-integer14": "The algorithm for reversing an integer involves initializing res as 0. Determine the sign of the input integer and take its absolute value. Iterate through each digit of x from right to left, updating res by multiplying it by 10 and adding the last digit of x. Adjust res based on the sign and return the result within the 32-bit range.",
  "valid-parentheses": "The algorithm uses a stack data structure to check the validity of the input string. It iterates through the string one character at a time. When an open bracket is encountered, it is pushed onto the stack. When a close bracket is encountered, the algorithm checks if the stack is empty or the corresponding open bracket is not at the top of the stack. If either of these conditions is true, the function returns false. If not, the open bracket is popped from the stack. After iterating through the entire string, the function checks if the stack is empty. If the stack is not empty, the function returns false, indicating there were unmatched open braces. Otherwise, the function returns true, indicating that the string is valid.",
  "merge-intervals": "The algorithm first sorts the intervals based on their start time. Then, it initializes an empty list `result` to store the merged intervals, and adds the first interval to `result`. Next, it iterates through the remaining intervals, comparing the end time of the last interval in `result` to the start time of the current interval. If they overlap (i.e., the end time of the last interval in `result` is greater than or equal to the start time of the current interval), then the end time of the last interval in `result` is updated to the maximum of its own end time and the end time of the current interval. Otherwise, the current interval is added to `result`. The process continues until all intervals have been processed, and `result` contains the merged, non-overlapping intervals covering the input intervals.",
  "word-search": "For each of the implementation above, we use a Depth-First Search (DFS) based algorithm to traverse the grid board. The DFS function takes the current cell index i and j and the index of the character in the input word that we are looking for (k).The base cases are:- If the cell indexes i or j are out of boundaries, or the board[i][j] character does not match word[k], return false.- If k (current character index) is equal to word.length - 1, we find the word in the grid, so return true.For each cell, we run the DFS function with the given input parameters. If DFS returns true (found the word), the whole function will return true.",
  "decode-ways": "We use dynamic programming (DP) to solve this problem. The `dp` array is of size `n+1`, where `n` is the length of the input string `s`. `dp[i]` stores the number of ways to decode the substring `s[0:i]`.Initialize `dp[0]` to 1 because there is always one way to decode an empty string.For each character in the string `s`, consider its corresponding one-digit and two-digits representations. If the one-digit representation is valid (>=1), we can increment `dp[i]` by `dp[i-1]`, which means one more way to decode the string by using the one-digit representation of the current character. If the two-digits representation is valid (>=10 and <=26), we can increment `dp[i]` by `dp[i-2]`, meaning one way to decode the string by using the two-digits representation of the current character.After we finished iterating through the string `s`, `dp[n]` will store the number of ways to decode the entire string.",
  "binary-tree-maximum-path-sum": "The algorithm is based on Depth First Search (DFS) traversal of the binary tree.1. Create a helper function that takes the root and maximum path sum reference as the input parameters.2. If the current node (root) is null, return 0.3. Call the helper function recursively for the left and right child nodes:   - Set `left` as the maximum of 0 and the helper function call for the left child.   - Set `right` as the maximum of 0 and the helper function call for the right child.4. Update the maximum path sum using the current maximum, the sum of the current node's value, and the left and right children's values.5. Return the sum of the current node's value and the maximum of the left and right subtrees.Call the helper function with the given binary tree root and return the maximum path sum.",
  "course-schedule": "The algorithm uses the topological sorting approach utilizing Kahn's Algorithm to solve this problem. We maintain an adjacency list to represent the graph and a list of in-degrees for each vertex (course) Mark the vertices with in-degree 0 and add them to a queue (these are starter courses). Then, we process each node (course) in the queue, decrease in-degrees of their neighbors (courses they unlock). If the in-degree of any neighbor becomes 0, add it to the queue. In the end, if we have processed all courses, return true; otherwise, return false if any course is not processed.",
  "two-sum": "The algorithm leverages a hash map (unordered_map in C++, HashMap in Java, dictionary in Python, and Map in JavaScript). It iterates through the given 'nums' array and calculates the complementary value (target - current value). If the complementary value is already in the hash map, it means that we found a solution, and we return those indices. If the complement is not in the hash map, we store the current element in the hash map with its index. If the algorithm doesn't find the solution, it returns an empty array or throws an exception (in Java).This approach has a time complexity of O(n) and a space complexity of O(n) as well."
}